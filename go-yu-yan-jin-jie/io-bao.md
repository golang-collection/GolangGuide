# io包

io包可以以流的方式高效处理数据，而不用考虑数据是什么，数据来自哪里，以及数据要发送到哪里的问题。

## Write和Reader接口

```go
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

Write 从 p 里向底层的数据流写入 len\(p\)字节的数据。这个方法返回从 p 里写出的字节 数（0 &lt;= n &lt;= len\(p\)），以及任何可能导致写入提前结束的错误。Write 在返回 n &lt; len\(p\)的时候，必须返回某个非 nil 值的 error。Write 绝不能改写切片里的数据， 哪怕是临时修改也不行。

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

* Read 最多读入 len\(p\)字节，保存到 p。这个方法返回读入的字节数（0 &lt;= n &lt;= len\(p\)）和任何读取时发生的错误。即便 Read 返回的 n &lt; len\(p\)，方法也可能使用所有 p 的空间存储临时数据。如果数据可以读取，但是字节长度不足 len\(p\)，习惯上 Read 会立刻返回可用的数据，而不等待更多的数据。
* 当成功读取 n &gt; 0 字节后，如果遇到错误或者文件读取完成，Read 方法会返回读入的字节数。方法可能会在本次调用返回一个非 nil 的错误，或者在下一次调用时返回错误（同时 n == 0）。这种情况的的一个例子是，在输入的流结束时，Read 会返回非零的读取字节数，可能会返回 err == EOF，也可能会返回 err == nil。无论如何，下一次调用 Read 应该返回 0, EOF。
* 调用者在返回的 n &gt; 0 时，总应该先处理读入的数据， 再处理错误 err。这样才能正确操作读取一部分字节后发生的 I/O 错误。EOF 也要这样处理。
* Read 的实现不鼓励返回 0 个读取字节的同时，返回 nil 值的错误。调用者需要将这种返回状态视为没有做任何操作，而不是遇到读取结束。




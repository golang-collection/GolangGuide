# 赋值语句中的表达式估值和赋值执行顺序

一条赋值语句的执行分为两个阶段。 首先，做为目标值的元素索引表达式中的容器值表达式和索引值表达式、做为目标值的指针解引用表达式中的指针值表达式、以及此赋值语句中的其它非目标值表达式将按照上述通常估值顺序估值。 然后，各个单值赋值将按照从左到右的顺序执行。

以后，我们可以称第一个阶段为估值阶段，称第二个阶段为实施阶段。

Go白皮书并没有清楚地说明在第二个阶段中发生的赋值操作是否会对在第一个阶段结尾确定下来的各个子表达式的估值结果造成影响，此举曾造成了[一些](https://github.com/golang/go/issues/23188#issuecomment-403951267)[争议](https://github.com/golang/go/issues/15620)。 所以，这里下面将对赋值语句中的表达式估值顺序做出一些补充解释。

首先，先明确一下：第二个阶段中发生的赋值操作绝不会对在第一个阶段结尾确定下来的各个子表达式的估值结果造成影响.

为了方便下面的解释，对于一个赋值语句，我们假设一个做为目标值的容器（切片或者映射）元素索引表达式中的映射值总是可寻址的。 如果它是不可寻址的，我们可以认为在实施第二个阶段之前，此容器值已经被赋给了一个临时变量（可寻址的）并且在此赋值语句中此容器值已经被此临时变量取代。在估值阶段结束之后、实施阶段开始之前的时刻，赋值语句中的每个目标值表达式都已经被估值为它的最基本形式。 不同风格的目标值表达式有着不同的最基本形式：

* 如果一个目标值表达式是一个空标识符，则它的最基本形式依旧是一个空标识符；
* 如果一个目标值表达式是一个容器（数组或者切片或者映射）元素索引表达式`c[k]`，则它的最基本形式为`(*cAddr)[k]`，其中一个`cAddr`为指向`c`的指针；
* 对于其它情形的任何一个目标值表达式，它必然是可寻址的，则它的最基本形式为它的地址的解引用形式。

假设`a`和`b`为两个可寻址的同类型变量，则下面的赋值语句

```text
	a, b = b, a
```

将按照如下步骤执行：

```text
// 估值阶段
P0 := &a; P1 := &b
R0 := a; R1 := b

// 最基本形式：*P0, *P1 = R0, R1

// 实施阶段
*P0 = R0
*P1 = R1
```

下面是另外一个例子，其中`x[0]`而不是`x[1]`被修改了。

```text
	x := []int{0, 0}
	i := 0
	i, x[i] = 1, 2
	fmt.Println(x) // [2 0]
```

上例中的第3行的分解执行步骤如下：

```text
// 估值阶段
P0 := &i; P1 := &x; T2 := i
R0 := 1; R1 := 2
// 到这里，T2 == 0

// 最基本形式：*P0, (*P1)[T2] = R0, R1

// 实施阶段
*P0 = R0
(*P1)[T2] = R1
```

下面是一个略为复杂一点的例子。

```text
package main

import "fmt"

func main() {
	m := map[string]int{"Go": 0}
	s := []int{1, 1, 1}; olds := s
	n := 2
	p := &n
	s, m["Go"], *p, s[n] = []int{2, 2, 2}, s[1], m["Go"], 5
	fmt.Println(m, s, n) // map[Go:1] [2 2 2] 0
	fmt.Println(olds)    // [1 1 5]
}
```

上例中的第10行的分解执行步骤如下：

```text
// 估值阶段
P0 := &s; PM1 := &m; K1 := "Go"; P2 := p; PS3 := &s; T3 := 2
R0 := []int{2, 2, 2}; R1 := s[1]; R2 := m["Go"]; R3 := 5
// 到这里，R1 == 1, R2 == 0

// 最基本形式：*P0, (*PM1)[K1], *P2, (*PS3)[T3] = R0, R1, R2, R3

// 实施阶段
*P0 = R0
(*PM1)[K1] = R1
*P2 = R2
(*PS3)[T3] = R3
```

下面这个例子将一个切片中的所有元素循环顺移了一位。

```text
	x := []int{2, 3, 5, 7, 11}
	t := x[0]
	var i int
	for i, x[i] = range x {}
	x[i] = t
	fmt.Println(x) // [3 5 7 11 2]
```

另一个例子：

```text
	x := []int{123}
	x, x[0] = nil, 456        // 此句不会发生恐慌
	x, x[0] = []int{123}, 789 // 此句将产生恐慌
```

尽管使用复杂的多值赋值语句是合法的，但是在实践中并不推荐使用，因为复杂多值赋值语句的可读性不高，编译速度较慢，并且执行效率相对略低。上面已经提到了，并非所有的估值顺序都在Go白皮书中指定清楚了，所以不同的Go编译器对这些未指定的估值顺序有着自己的理解。 一些跨编译器兼容性不好的代码将导致使用不同的编译器编译的程序的运行结果不同。 在下面这个例子中，表达式`x+1`和`f(&x)`的估值顺序是编译器相关的，所以此程序输出`100 99`或者`1 99`都是合理的。

```text
package main

import "fmt"

func main() {
	f := func (p *int) int {
		*p = 99
		return *p
	}

	x := 0
	y, z := x+1, f(&x)
	fmt.Println(y, z)
}
```

下面是另一个可能输出不同结果的程序。它可能输出`1 7 2`、`1 8 2`或者`1 9 2`，取决于不同的编译器实现。

```text
package main

import "fmt"

func main() {
	x, y := 0, 7
	f := func() int {
		x++
		y++
		return x
	}
	fmt.Println(f(), y, f())
}
```


# 函数调用栈分析

> 整理自：[https://www.bilibili.com/video/BV1WZ4y1p7JT](https://www.bilibili.com/video/BV1WZ4y1p7JT)

根据操作系统的定义，首先会将编写的代码编译为可执行文件，然后通过链接和装入使程序可以被计算机正确的执行，在函数调用中，如果函数A调用函数B会使用call指令，函数B执行完毕就会通过ret指令返回。

对于每一个函数来说，go编译器都会为其分配足够的栈空间来存放局部变量，返回值和参数等。函数的栈帧布局如下所示

![](../../.gitbook/assets/image%20%2855%29.png)

在函数执行过程中，会通过对应的寄存器来存储对应的变量值。

![](../../.gitbook/assets/image%20%2849%29.png)

在go语言中会一次性为函数分配足够的栈空间，然后通过操作栈指针加偏移的方式来找到对应的位置存储对应的变量。之所以一次分配，主要是为了防止栈访问越界，如果某个函数需要较大的栈空间，那么编译器会在其头部插入检测代码，如果需要扩张时会在栈上分配另外一段足够大的栈空间，然后将原来栈上的数据拷贝过来，并将原来的栈空间释放。

下面来看几个例子

## 例1

![](../../.gitbook/assets/image%20%2846%29.png)

在swap函数中会交换a和b的值，那么交换的也就是对应参数args中a和b的值，当swap函数执行完成后，并没有修改main函数的两个局部变量所以就会导致交换失败。

## 例2

![](../../.gitbook/assets/image%20%2848%29.png)

上面这个例子中传入的是main函数局部变量a和b的地址，所以在swap函数中交换也会导致main函数中对应的局部变量值作出改变，所以可以交换成功。

## 例3

![](../../.gitbook/assets/image%20%2851%29.png)

函数执行到incr函数中的a++时，会将参数a的值修改为1，然后执行b=a会将incr函数中的b的值修改为1。

{% hint style="info" %}
函数调用结束之前，会先给返回值赋值，然后再执行defer函数
{% endhint %}

那么函数incr执行结束，就会将main中的return value处的值修改为1，然后执行defer函数，会讲参数a的值修改为2，将incr函数中的b也修改为2。incr函数就完全执行完毕了，然后将返回值赋值给main函数中的b变量，那么就会将b修改为1，所以程序输出0，1。

## 例4

与上一个例子不同的是这个例子中使用的是命名返回值，所以在incr函数的栈空间中不存在局部变量。

![](../../.gitbook/assets/image%20%2856%29.png)

首先执行a++，会讲参数a的值修改为1，接下来回先执行return函数，会将return value的值修改为1，接下来会执行defer函数，此时会将参数a的值修改为2，然后将renturn value的值也修改为2，然后将返回值2赋值给main的局部变量b，那么函数最终就会输出0，2。

当然这里仅考虑了栈上的空间分配，结合逃逸分析还会将一些变量分配到堆中。


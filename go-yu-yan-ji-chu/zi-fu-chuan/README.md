# 字符串

转载自：[https://github.com/unknwon/the-way-to-go\_ZH\_CN/blob/master/eBook/04.6.md](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.6.md) by unknwon

## 字符串简介

字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串里面的字符也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

字符串是一种值类型，且值不可变，即**创建某个文本后你无法再次修改这个文本的内容**；更深入地讲，字符串是字节的定长数组。

{% hint style="warning" %}
要修改字符串内容，必须将其转换为可变的类型\(\[\]byte, \[\]rune\)，完成后再将其转换为字符串。但是不管如何转换都需要重新分配内存。
{% endhint %}

Go 支持以下 2 种形式的字面值：

* 解释字符串：

  该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：

  * `\n`：换行符
  * `\r`：回车符
  * `\t`：tab 键
  * `\u` 或 `\U`：Unicode 字符
  * `\\`：反斜杠自身

* 非解释字符串：

  该类字符串使用反引号括起来，支持换行，例如：

  ```text
    `This is a raw string \n` 中的 `\n\` 会被原样输出。
  ```

## 字符串长度

和 C/C++不一样，Go 中的字符串是根据长度限定，而非特殊字符`\0`。

`string` 类型的零值为长度为零的字符串，即空字符串 `""`。

一般的比较运算符（`==`、`!=`、`<`、`<=`、`>=`、`>`）通过在内存中按字节比较来实现字符串的对比。你可以通过函数 `len()` 来获取字符串所占的字节长度，例如：`len(str)`。

字符串的内容（纯字节）可以通过标准索引法来获取，在中括号 `[]` 内写入索引，索引从 0 开始计数：

* 字符串 str 的第 1 个字节：`str[0]`
* 第 i 个字节：`str[i - 1]`
* 最后 1 个字节：`str[len(str)-1]`

需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。

{% hint style="info" %}
**注意事项** 获取字符串中某个字节的地址的行为是非法的，例如：`&str[i]`。
{% endhint %}

## **字符串拼接符 `+`**

两个字符串 `s1` 和 `s2` 可以通过 `s := s1 + s2` 拼接在一起。

`s2` 追加在 `s1` 尾部并生成一个新的字符串 `s`。

你可以通过以下方式来对代码中多行的字符串进行拼接：

```go
str := "Beginning of the string " +
	"second part of the string"
```

由于编译器行尾自动补全分号的缘故，加号 `+` 必须放在第一行。

拼接的简写形式 `+=` 也可以用于字符串：

```go
s := "hel" + "lo,"
s += "world!"
fmt.Println(s) //输出 “hello, world!”
```

**在循环中使用加号 `+` 拼接字符串并不是最高效的做法**，更好的办法是使用函数 `strings.Join()`有没有更好地办法了？有！使用字节缓冲（`bytes.Buffer`）拼接更加给力！

## 字符串包含中文

```go
//字符串中存在中文的处理方式,先将字符串转为rune切片再进行操作
	r := []rune(str)
	for i := 0; i< len(r); i++ {
		fmt.Printf("%c",r[i])
	}
	fmt.Println()
```

还需要注意的是，在go语言中如何获取中文字符串的长度。

```go
func main() {
	str := "Go语言你好"
	fmt.Println(len(str))
}

//输出
14
```

这里可以看到字符串的输出长度是14，直觉来说字符串的长度应该是6，这里的差异是由于 Go 语言的字符串都以 UTF-8 格式保存，每个中文占用 3 个字节，因此使用 len\(\) 获得中文文字对应的 12 个字节加上Go对应的两个字节。

如果想要获取中文数量需要使用以下方法

```go
func main() {
	str := "Go语言你好"
	fmt.Println(len(str))
	fmt.Println(utf8.RuneCountInString(str))
}
//输出
14
6
```

## 从字符串生成字节切片

假设 s 是一个字符串（本质上是一个字节数组），那么就可以直接通过 `c := []byte(s)` 来获取一个字节的切片 c。另外，您还可以通过 copy 函数来达到相同的目的：`copy(dst []byte, src string)`。

同样的，还可以使用 for-range 来获得每个元素（Listing 7.13—for\_string.go）：

```go
package main

import "fmt"

func main() {
    s := "\u00ff\u754c"
    for i, c := range s {
        fmt.Printf("%d:%c ", i, c)
    }
}
```

输出：

```text
0:ÿ 2:界
```

我们知道，Unicode 字符会占用 2 个字节，有些甚至需要 3 个或者 4 个字节来进行表示。如果发现错误的 UTF8 字符，则该字符会被设置为 U+FFFD 并且索引向前移动一个字节。和字符串转换一样，您同样可以使用 `c := []int32(s)` 语法，这样切片中的每个 int 都会包含对应的 Unicode 代码，因为字符串中的每次字符都会对应一个整数。类似的，您也可以将字符串转换为元素类型为 rune 的切片：`r := []rune(s)`。

可以通过代码 `len([]int32(s))` 来获得字符串中字符的数量，但使用 `utf8.RuneCountInString(s)` 效率会更高一点。

您还可以将一个字符串追加到某一个字节切片的尾部：

```go
var b []byte
var s string
b = append(b, s...)
```

## 获取字符串的某一部分

使用 `substr := str[start:end]` 可以从字符串 str 获取到从索引 start 开始到 `end-1` 位置的子字符串。同样的，`str[start:]` 则表示获取从 start 开始到 `len(str)-1` 位置的子字符串。而 `str[:end]` 表示获取从 0 开始到 `end-1` 的子字符串。

## 字符串和切片的内存结构

在内存中，一个字符串实际上是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数。因为指针对用户来说是完全不可见，因此我们可以依旧把字符串看做是一个值类型，也就是一个字符数组。

字符串 `string s = "hello"` 和子字符串 `t = s[2:3]` 在内存中的结构可以用下图表示：

![](https://github.com/unknwon/the-way-to-go_ZH_CN/raw/master/eBook/images/7.6_fig7.4.png)

## 修改字符串中的某个字符

Go 语言中的字符串是不可变的，也就是说 `str[index]` 这样的表达式是不可以被放在等号左侧的。如果尝试运行 `str[i] = 'D'` 会得到错误：`cannot assign to str[i]`。

因此，您必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式。

例如，将字符串 "hello" 转换为 "cello"：

```go
s := "hello"
c := []byte(s)
c[0] = 'c'
s2 := string(c) // s2 == "cello"
```

所以，您可以通过操作切片来完成对字符串的操作。

